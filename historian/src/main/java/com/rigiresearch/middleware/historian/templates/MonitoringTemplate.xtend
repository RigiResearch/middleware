package com.rigiresearch.middleware.historian

import com.rigiresearch.middleware.metamodels.monitoring.Array
import com.rigiresearch.middleware.metamodels.monitoring.DataType
import com.rigiresearch.middleware.metamodels.monitoring.Monitor
import com.rigiresearch.middleware.metamodels.monitoring.Property
import com.rigiresearch.middleware.metamodels.monitoring.Root
import com.rigiresearch.middleware.metamodels.monitoring.Schema
import com.rigiresearch.middleware.metamodels.monitoring.Type
import java.util.Date
import java.util.List

/**
 * Generate classes from the monitoring model. More specifically, from the
 * response schemas.
 *
 * TODO This class could be replaced by an ATL transformation from monitoring
 * to class diagram. Then, the class diagram would be used to generate the
 * classes.
 *
 * @author Miguel Jimenez (miguel@uvic.ca)
 * @date 2019-06-25
 * @version $Id$
 * @since 0.1.0
 */
final class MonitoringTemplate {

    /**
     * Creates a properties file based on the paths and their parameters.
     * @param root The root model element
     * @return The contents of a properties file
     */
    def asProperties(Root root) '''
        # File generated by Historian («new Date()»)
        # Please edit the parameter values only
        #
        paths=«root.monitors.map[m|m.path.id].join(", ")»
        «FOR m : root.monitors»
            «m.path.id».url=«root.baseUrl»«m.path.url»
            «m.path.id».expression=«m.rate.value»
            «IF !m.path.parameters.empty»
                # TODO set a value for «IF m.path.parameters.size == 1»this parameter«ELSE»these parameter«ENDIF»
                «m.path.id».parameters=«m.path.parameters.map[p|p.name].join(", ")»
                «FOR p : m.path.parameters»
                    «m.path.id».«p.name».value=
                    «m.path.id».«p.name».location=«p.location.toString.toUpperCase»
                «ENDFOR»
            «ENDIF»
        «ENDFOR»
    '''

    /**
     * Puts together the base URL.
     * @param root The root model element
     * @return The base URL
     */
    def private baseUrl(Root root) '''
        http«IF root.https»s«ENDIF»://«root.host»«root.basePath»
    '''

    /**
     * Generates a Java (value) class for a particular schema object.
     * This template assumes that a path always returns an object, therefore
     * its properties are rendered as class attributes. TODO In case a primitive
     * value is returned instead, that primitive value would need to be rendered
     * as an attribute itself.
     *
     * <b>Not supported types</b>: FILE, NULL, UNSPECIFIED (See enum Type in the
     * monitoring model)
     * @param monitor The associated monitor
     * @return The contents of a Java class
     */
    def asJavaClass(Monitor monitor) '''
        package com.rigiresearch.middleware.historian.api;

        import javax.annotation.Generated;

        import lombok.Value;
        import lombok.experimental.Accessors;

        /**
         * Response object for path '<em><b>«monitor.path.id»</b></em>'.
         */
        @Accessors(fluent = true)
        @Value
        @Generated(value = "Historian", date = "«new Date()»")
        public final class «monitor.path.id.toFirstUpper» {

            «FOR property : monitor.schema.properties»
                «property.asJavaField»
            «ENDFOR»

            «FOR property : monitor.schema.properties.filter[p|p.type.hasInnerClass]»
                «property.asInnerClasses»
            «ENDFOR»

        }
    '''

    /**
     * Maps the given property to its Java type version.
     * @param property The schema property
     * @return The name of the corresponding Java type
     */
    def private asJavaType(Property property) {
        property.type.asJavaType(property.name, 0)
    }

    /**
     * Maps the given data type to its Java version.
     * @param type The data type
     * @param name The name of the associated property
     * @param calls The number of inner calls
     * @return The name of the corresponding Java type
     */
    def private String asJavaType(DataType type, String name, int calls) {
        switch type {
            Schema: '''«name.asClassName»«calls»'''
            Array: '''«type.subtype.asJavaType(name + type.hashCode, calls + 1)»[]'''
            default: type.type.asJavaType
        }
    }

    /**
     * Maps the given primitive type to its Java version.
     * @param type The primitive type
     * @return The name of the corresponding Java primitive type
     */
    def private asJavaType(Type type) {
        switch type {
            case BOOLEAN: "boolean"
            case INTEGER: "int"
            case NUMBER: "double"
            case STRING: "String"
            default: this.fail(type)
        }
    }

    /**
     * Throws {@link IllegalArgumentException} to notify about an unsupported
     * type.
     * @param type The unsupported type.
     */
    def private fail(Type type) {
        throw new IllegalArgumentException(
            '''Unsupported property value «type.toString»'''
        );
    }

    /**
     * Converts from snake case to camel case.
     * @param name The original name
     * @return A valid camel-case class name
     */
    def private asClassName(String name) {
        name.split("_").map[t|t.substring(0, 1).toUpperCase + t.substring(1)].join
    }

    /**
     * Creates inner classes (as Strings) based on a given property.
     * @param property The schema property
     * @return Java code containing the inner classes and nothing else
     */
    def private asInnerClasses(Property property) {
        this.asInnerClasses(property.name, property.type, 0).join("\n")
    }

    /**
     * Creates inner classes (as Strings) based on a given data type. This
     * method is recursive.
     * @param name The associated property's name
     * @param type The current data type being consider for class creation
     * @param calls The number of inner calls
     * @return A list of inner classes
     */
    def private List<String> asInnerClasses(String name, DataType type, int calls) {
        val classes = newArrayList
        switch type {
            Schema: {
                val clazz = '''
                /**
                 * Java class for schema object from property '<em><b>«name»</b></em>'.
                 */
                @Accessors(fluent = true)
                @Value
                public final class «name.asClassName»«calls» {

                    «FOR property : type.properties»
                        «property.asJavaField»
                        ««« Recursive call: is this attribute an Object or Array?
                        «classes.addAll(this.asInnerClasses(property.name, property.type, 0))»
                    «ENDFOR»

                }
                '''
                classes.add(clazz)
            }
            Array: {
                classes.addAll(
                    // Recursive call: is the sub-type an Object or Array?
                    this.asInnerClasses(
                        name + type.hashCode,
                        type.subtype,
                        calls + 1
                    )
                )
            }
        }
        return classes
    }

    /**
     * Determines whether an inner class is necessary. That is, the property
     * type references an object or is an object itself.
     * @param type The data type
     * @return Whether an inner class is necessary
     */
    def private boolean hasInnerClass(DataType type) {
        switch type {
            Schema: true
            Array: type.subtype.hasInnerClass
            default: false
        }
    }

    /**
     * Creates a valid Java field declaration without initialization.
     * @param property The associated property
     * @return A field declaration
     */
    def private asJavaField(Property property) '''
        /**
         * The value of the '<em><b>«property.name»</b></em>'.
         */
        private final «property.asJavaType» «property.name»;
    '''

}
