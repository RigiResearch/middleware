package com.rigiresearch.middleware.historian.runtime;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.rigiresearch.middleware.graph.Graph;
import com.rigiresearch.middleware.graph.GraphParser;
import com.rigiresearch.middleware.historian.runtime.graph.Monitor;
import it.sauronsoftware.cron4j.Scheduler;
import java.io.File;
import java.io.IOException;
import javax.xml.bind.JAXBException;
import org.apache.commons.configuration2.CompositeConfiguration;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.FileBasedConfiguration;
import org.apache.commons.configuration2.PropertiesConfiguration;
import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The main class.
 * @author Miguel Jimenez (miguel@uvic.ca)
 * @version $Id$
 * @since 0.1.0
 */
@SuppressWarnings("checkstyle:ClassDataAbstractionCoupling")
public final class Application {

    /**
     * The logger.
     */
    private static final Logger LOGGER =
        LoggerFactory.getLogger(Application.class);

    /**
     * A JSON object mapper.
     */
    private static final ObjectMapper MAPPER = new ObjectMapper();

    /**
     * The configuration generated by Historian.
     */
    private final Configuration config;

    /**
     * The task scheduler.
     */
    private final Scheduler scheduler;

    /**
     * The current JSON object.
     */
    private JsonNode previous;

    /**
     * Default constructor.
     * @throws ConfigurationException If there is an error building the
     *  configuration
     */
    private Application() throws ConfigurationException {
        this.config = Application.initialize();
        this.scheduler = new Scheduler();
        this.previous = Application.MAPPER.createObjectNode();
    }

    /**
     * The main entry point.
     * @param args The program arguments
     */
    public static void main(final String... args) {
        try {
            new Application().start();
        } catch (final ConfigurationException | JAXBException exception) {
            Application.LOGGER.error(exception.getMessage(), exception);
        }
    }

    /**
     * Loads the configuration file.
     * @return A {@link Configuration} instance.
     * @throws ConfigurationException If there is an error building the
     *  configuration
     */
    private static Configuration initialize() throws ConfigurationException {
        final Parameters params = new Parameters();
        final FileBasedConfigurationBuilder<FileBasedConfiguration> properties =
            new FileBasedConfigurationBuilder<FileBasedConfiguration>(
                PropertiesConfiguration.class
            ).configure(
                params.properties()
                    .setListDelimiterHandler(new DefaultListDelimiterHandler(','))
                    .setFileName("default.properties")
            );
        final FileBasedConfigurationBuilder<FileBasedConfiguration> custom =
            new FileBasedConfigurationBuilder<FileBasedConfiguration>(
                PropertiesConfiguration.class
            ).configure(
                params.properties()
                    .setListDelimiterHandler(new DefaultListDelimiterHandler(','))
                    .setFileName("custom.properties")
            );
        final CompositeConfiguration composite = new CompositeConfiguration();
        composite.addConfiguration(custom.getConfiguration());
        composite.addConfiguration(properties.getConfiguration());
        return composite;
    }

    /**
     * Start the monitors.
     * @throws JAXBException If anything fails reading the configuration graph
     */
    private void start() throws JAXBException {
        final Graph<Monitor> graph = new GraphParser()
            .withBindings("bindings.xml")
            .instance(
                new File(
                    Thread.currentThread()
                        .getContextClassLoader()
                        .getResource("configuration.xml")
                        .getFile()
                )
            );
        final ForkAndCollectAlgorithm algorithm =
            new ForkAndCollectAlgorithm(graph, this.config);
        this.scheduler.schedule(
            this.config.getString("periodicity"), () -> this.collect(algorithm)
        );
        this.scheduler.start();
        Runtime.getRuntime()
            .addShutdownHook(new Thread(this.scheduler::stop));
    }

    /**
     * Collects the data from the remote server.
     * @param algorithm An instance of the Fork and Collect algorithm
     */
    private void collect(final ForkAndCollectAlgorithm algorithm) {
        try {
            final JsonNode result = algorithm.data();
            if (result.equals(this.previous)) {
                Application.LOGGER.info("The monitored resources have not changed");
            } else {
                this.previous = result;
                Application.LOGGER.info(
                    "{}",
                    Application.MAPPER.writeValueAsString(this.previous)
                );
            }
        } catch (final UnexpectedResponseCodeException | IOException
            | com.rigiresearch.middleware.historian.runtime.ConfigurationException exception) {
            throw new IllegalStateException(exception);
        }
    }

}
